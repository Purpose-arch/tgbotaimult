import os
import logging
import sqlite3
import asyncio
import time
from datetime import datetime
from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, types, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from openai import AsyncOpenAI, APIConnectionError, RateLimitError, APIError

load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
BASE_URL = "https://openrouter.ai/api/v1"
HISTORY_LIMIT = 10

if not OPENROUTER_API_KEY:
    raise ValueError("OPENROUTER_API_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env")
if not BOT_TOKEN:
    raise ValueError("TELEGRAM_BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
class Database:
    def __init__(self):
        self.conn = sqlite3.connect('chat_history.db')
        self._create_tables()

    def _create_tables(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS chats (
                chat_id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                model TEXT,
                created_at DATETIME,
                title TEXT
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS history (
                message_id INTEGER PRIMARY KEY AUTOINCREMENT,
                chat_id INTEGER,
                role TEXT,
                content TEXT,
                timestamp DATETIME
            )
        ''')
        self.conn.commit()

    def create_chat(self, user_id: int, model: str, title: str):
        cursor = self.conn.cursor()
        cursor.execute('''
            INSERT INTO chats (user_id, model, created_at, title)
            VALUES (?, ?, ?, ?)
        ''', (user_id, model, datetime.now(), title))
        self.conn.commit()
        return cursor.lastrowid

    def get_chats(self, user_id: int):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT chat_id, title, model FROM chats 
            WHERE user_id = ? 
            ORDER BY created_at DESC
        ''', (user_id,))
        return cursor.fetchall()

    def delete_chat(self, chat_id: int):
        cursor = self.conn.cursor()
        cursor.execute('DELETE FROM chats WHERE chat_id = ?', (chat_id,))
        cursor.execute('DELETE FROM history WHERE chat_id = ?', (chat_id,))
        self.conn.commit()

    def rename_chat(self, chat_id: int, new_title: str):
        cursor = self.conn.cursor()
        cursor.execute('''
            UPDATE chats SET title = ? 
            WHERE chat_id = ?
        ''', (new_title, chat_id))
        self.conn.commit()

    def add_message(self, chat_id: int, role: str, content: str):
        cursor = self.conn.cursor()
        cursor.execute('''
            INSERT INTO history (chat_id, role, content, timestamp)
            VALUES (?, ?, ?, ?)
        ''', (chat_id, role, content, datetime.now()))
        self.conn.commit()

    def get_history(self, chat_id: int, limit: int = HISTORY_LIMIT):
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT role, content FROM history 
            WHERE chat_id = ? 
            ORDER BY timestamp DESC 
            LIMIT ?
        ''', (chat_id, limit))
        result = cursor.fetchall()
        return [{"role": role, "content": content} for role, content in reversed(result)]

    def clear_history(self, chat_id: int):
        cursor = self.conn.cursor()
        cursor.execute('DELETE FROM history WHERE chat_id = ?', (chat_id,))
        self.conn.commit()

db = Database()

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

client = AsyncOpenAI(
    base_url=BASE_URL,
    api_key=OPENROUTER_API_KEY,
)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–æ–≤–∞—Ä—è –º–æ–¥–µ–ª–µ–π –∫–∞–∫ –ø—É—Å—Ç–æ–≥–æ (–±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏)
MODELS = {}

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
async def get_available_models():
    try:
        response = await client.models.list()
        # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –º–æ–¥–µ–ª–∏
        return [model.id for model in response.data if model.id.endswith(":free")]
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –º–æ–¥–µ–ª–µ–π: {e}")
        return []

# –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è MODELS
async def update_models():
    global MODELS
    available_models = await get_available_models()
    MODELS = {model: model.split('/')[-1].replace(':free', '') for model in available_models}

# –ó–∞–ø—É—Å–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–æ–¥–µ–ª–µ–π –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
asyncio.run(update_models())

class ChatStates(StatesGroup):
    choosing_model = State()
    naming_chat = State()
    renaming_chat = State()
    waiting_for_message = State()

def main_menu_keyboard():
    builder = ReplyKeyboardBuilder()
    builder.add(types.KeyboardButton(text="‚ûï –ù–æ–≤—ã–π —á–∞—Ç"))
    builder.add(types.KeyboardButton(text="üìÇ –ú–æ–∏ —á–∞—Ç—ã"))
    builder.add(types.KeyboardButton(text="üìä –¢–µ–∫—É—â–∏–π —á–∞—Ç"))
    builder.add(types.KeyboardButton(text="üßπ –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é"))
    builder.add(types.KeyboardButton(text="üì§ –≠–∫—Å–ø–æ—Ä—Ç –∏—Å—Ç–æ—Ä–∏–∏"))
    builder.adjust(2, 2)
    return builder.as_markup(resize_keyboard=True)

def model_selection_keyboard():
    builder = ReplyKeyboardBuilder()
    for model in MODELS.values():
        builder.add(types.KeyboardButton(text=model))
    builder.add(types.KeyboardButton(text="‚Ü©Ô∏è –ù–∞–∑–∞–¥"))
    builder.adjust(1)
    return builder.as_markup(resize_keyboard=True)

@dp.message(F.text == "/start")
async def cmd_start(message: types.Message, state: FSMContext):
    await message.answer("ü§ñ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –Ω–µ–π—Ä–æ-—á–∞—Ç!")
    await message.answer(
        "üëá –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=main_menu_keyboard()
    )

@dp.message(F.text == "/menu")
async def cmd_menu(message: types.Message, state: FSMContext):
    await message.answer(
        "üìù –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
        reply_markup=main_menu_keyboard()
    )

@dp.message(F.text == "‚ûï –ù–æ–≤—ã–π —á–∞—Ç")
async def create_new_chat(message: types.Message, state: FSMContext):
    if not MODELS:
        await message.answer("‚ö†Ô∏è –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return
    await state.set_state(ChatStates.choosing_model)
    await message.answer(
        "ü§ñ –í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –¥–ª—è –Ω–æ–≤–æ–≥–æ —á–∞—Ç–∞:",
        reply_markup=model_selection_keyboard()
    )

@dp.message(F.text.in_(MODELS.values()), ChatStates.choosing_model)
async def model_selected(message: types.Message, state: FSMContext):
    selected_model_name = message.text
    model_key = next((k for k, v in MODELS.items() if v == selected_model_name), None)
    if model_key:
        await state.update_data(selected_model=model_key)
        await state.set_state(ChatStates.naming_chat)
        await message.answer(
            "üìù –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –Ω–æ–≤–æ–≥–æ —á–∞—Ç–∞:",
            reply_markup=types.ReplyKeyboardRemove()
        )
    else:
        await message.answer("‚ùå –í—ã–±—Ä–∞–Ω–Ω–∞—è –º–æ–¥–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é.")

@dp.message(ChatStates.naming_chat)
async def chat_named(message: types.Message, state: FSMContext):
    data = await state.get_data()
    model_key = data['selected_model']
    title = message.text[:30]
    
    chat_id = db.create_chat(message.from_user.id, model_key, title)
    await state.update_data(current_chat=chat_id)
    await state.set_state(ChatStates.waiting_for_message)
    await message.answer(
        f"‚úÖ –ß–∞—Ç '{title}' —Å–æ–∑–¥–∞–Ω!\n–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å –æ–±—â–µ–Ω–∏–µ!",
        reply_markup=main_menu_keyboard()
    )

@dp.message(F.text == "üìÇ –ú–æ–∏ —á–∞—Ç—ã")
async def show_chats(message: types.Message):
    user_id = message.from_user.id
    chats = db.get_chats(user_id)
    
    if not chats:
        await message.answer("üì≠ –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤")
        return
    
    builder = InlineKeyboardBuilder()
    for chat in chats:
        model_display = MODELS.get(chat[2], chat[2])  # –ï—Å–ª–∏ –º–æ–¥–µ–ª—å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–ª—é—á
        builder.row(types.InlineKeyboardButton(
            text=f"{chat[1]} ({model_display})",
            callback_data=f"chat_{chat[0]}"
        ))
        builder.row(types.InlineKeyboardButton(
            text="‚úèÔ∏è –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å",
            callback_data=f"rename_{chat[0]}"
        ), types.InlineKeyboardButton(
            text="üóëÔ∏è –£–¥–∞–ª–∏—Ç—å",
            callback_data=f"delete_{chat[0]}"
        ))
    builder.row(types.InlineKeyboardButton(
        text="‚ôªÔ∏è –û–±–Ω–æ–≤–∏—Ç—å",
        callback_data="refresh_chats"
    ))
    
    await message.answer(
        "üìÇ –í–∞—à–∏ —á–∞—Ç—ã:",
        reply_markup=builder.as_markup()
    )

@dp.callback_query(F.data == "refresh_chats")
async def refresh_chats(callback: types.CallbackQuery):
    await show_chats(callback.message)
    await callback.answer("‚ôªÔ∏è –°–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω")

@dp.callback_query(F.data.startswith("chat_"))
async def select_chat(callback: types.CallbackQuery, state: FSMContext):
    chat_id = int(callback.data.split("_")[1])
    await state.update_data(current_chat=chat_id)
    await callback.message.answer(
        "‚úÖ –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–æ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π —á–∞—Ç",
        reply_markup=main_menu_keyboard()
    )
    await callback.answer()

@dp.message(F.text == "üìä –¢–µ–∫—É—â–∏–π —á–∞—Ç")
async def show_current_chat(message: types.Message, state: FSMContext):
    data = await state.get_data()
    chat_id = data.get('current_chat')
    if chat_id:
        chats = db.get_chats(message.from_user.id)
        chat_info = next((c for c in chats if c[0] == chat_id), None)
        if chat_info:
            model_display = MODELS.get(chat_info[2], chat_info[2])
            await message.answer(f"üîÆ –ê–∫—Ç–∏–≤–Ω—ã–π —á–∞—Ç: {chat_info[1]}\n–ú–æ–¥–µ–ª—å: {model_display}")
            return
    await message.answer("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —á–∞—Ç–∞")

@dp.message(F.text == "üì§ –≠–∫—Å–ø–æ—Ä—Ç –∏—Å—Ç–æ—Ä–∏–∏")
async def export_history(message: types.Message, state: FSMContext):
    data = await state.get_data()
    chat_id = data.get('current_chat')
    
    if not chat_id:
        await message.answer("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —á–∞—Ç–∞")
        return
    
    history = db.get_history(chat_id, limit=100)
    formatted = "\n\n".join([f"{msg['role']}: {msg['content']}" for msg in history])
    
    await message.answer_document(
        types.BufferedInputFile(
            formatted.encode('utf-8'), 
            filename=f"chat_history_{chat_id}.txt"
        ),
        caption="üìù –ò—Å—Ç–æ—Ä–∏—è –≤–∞—à–µ–≥–æ —á–∞—Ç–∞"
    )

async def check_model_availability(model_key: str) -> bool:
    try:
        await client.models.retrieve(model_key)
        return True
    except Exception:
        return False

@dp.message(F.text, ChatStates.waiting_for_message)
async def handle_message(message: types.Message, state: FSMContext):
    data = await state.get_data()
    chat_id = data.get('current_chat')
    
    if not chat_id:
        await message.answer("‚ùå –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ —á–∞—Ç!")
        return
    
    db.add_message(chat_id, "user", message.text)
    
    try:
        chats = db.get_chats(message.from_user.id)
        chat_info = next((c for c in chats if c[0] == chat_id), None)
        if not chat_info:
            await message.answer("‚ùå –ß–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
            
        model_key = chat_info[2]

        history = db.get_history(chat_id)
        
        sent_message = await message.answer("‚óè")
        full_answer = ""
        last_edit_time = time.monotonic()
        edit_interval = 1.5
        
        stream = await client.chat.completions.create(
            model=model_key,
            messages=history + [{"role": "user", "content": message.text}],
            stream=True,
            extra_headers={
                "HTTP-Referer": "https://github.com/Purpose-arch/tgbotaimult",
                "X-Title": "tgbotaimult"
            }
        )
        
        async for chunk in stream:
            if chunk.choices[0].delta.content:
                delta_content = chunk.choices[0].delta.content
                full_answer += delta_content
                now = time.monotonic()
                if now - last_edit_time >= edit_interval or len(delta_content) < 3:
                    try:
                        await sent_message.edit_text(full_answer + "‚óè")
                        last_edit_time = now
                    except Exception as e:
                        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
        
        await sent_message.edit_text(full_answer)
        db.add_message(chat_id, "assistant", full_answer)
        
    except APIConnectionError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {str(e)}")
        await message.answer("üîå –ü—Ä–æ–±–ª–µ–º—ã —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ API")
    except RateLimitError as e:
        logger.error(f"–õ–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤: {str(e)}")
        await message.answer("‚è≥ –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ")
    except APIError as e:
        logger.error(f"API –æ—à–∏–±–∫–∞: {str(e)}")
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ API, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞: {str(e)}")
        await message.answer("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞")

@dp.callback_query(F.data.startswith("delete_"))
async def delete_chat(callback: types.CallbackQuery):
    chat_id = int(callback.data.split("_")[1])
    db.delete_chat(chat_id)
    await callback.message.edit_text(f"‚úÖ –ß–∞—Ç —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω")
    await callback.answer()

@dp.callback_query(F.data.startswith("rename_"))
async def rename_chat_start(callback: types.CallbackQuery, state: FSMContext):
    chat_id = int(callback.data.split("_")[1])
    await state.set_state(ChatStates.renaming_chat)
    await state.update_data(renaming_chat=chat_id)
    await callback.message.answer(
        "üìù –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è —á–∞—Ç–∞:",
        reply_markup=types.ReplyKeyboardRemove()
    )
    await callback.answer()

@dp.message(ChatStates.renaming_chat)
async def rename_chat_finish(message: types.Message, state: FSMContext):
    data = await state.get_data()
    chat_id = data['renaming_chat']
    new_title = message.text[:30]
    
    db.rename_chat(chat_id, new_title)
    await state.clear()
    await message.answer(
        f"‚úÖ –ù–∞–∑–≤–∞–Ω–∏–µ —á–∞—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ '{new_title}'",
        reply_markup=main_menu_keyboard()
    )

@dp.message(F.text == "üßπ –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é")
async def clear_history(message: types.Message, state: FSMContext):
    data = await state.get_data()
    chat_id = data.get('current_chat')
    if chat_id:
        db.clear_history(chat_id)
        await message.answer("‚úÖ –ò—Å—Ç–æ—Ä–∏—è —Ç–µ–∫—É—â–µ–≥–æ —á–∞—Ç–∞ –æ—á–∏—â–µ–Ω–∞")
    else:
        await message.answer("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —á–∞—Ç–∞")

if __name__ == "__main__":
    asyncio.run(dp.start_polling(bot))